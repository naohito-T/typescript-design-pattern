# Iteratorパターン

## 概要

iteratorという単語は「繰り返す」という意味であり、日本語だと反復子などと呼ばれる。  
Iterator（イテレータ）パターンは、コレクションオブジェクトの要素に順番にアクセスする方法を提供します。このパターンを使用することで、コレクションの内部構造を知らない状態で、その要素にアクセスしたり、走査したりすることができる。

## 例

>たとえば、集約オブジェクトとして List クラスを想定してみましょう。 List クラスは、要素としていくつかのオブジェクトを持つことができるものとします。 このList オブジェクトが持つ要素に順番にアクセスするような場合、 どのような順番で各要素にアクセスするのかによって、さまざまな走査方法が考えられます。 例えば、各オブジェクトが持つ名前の順番にアクセスしたい場合が考えられますし、 各オブジェクトの何らかのパラメータを利用して走査したい場合もあるでしょう。 それでは、これらの「走査方法」は誰が提供すればよいでしょう？ List クラスですべての走査方法を提供することは不可能です。 なぜなら、走査方法は、その目的によって、さまざまなものが考えられ、 そのすべてをあらかじめ用意しておくことができないからです。 そこで、この走査方法を与えるクラスを List クラスとは独立させておきます。 すると、必要な走査方法を与えるクラスをユーザが自分で作成し、 これを利用できるようになり、より柔軟な設計となるわけです。

>また、集約オブジェクトとして利用するクラスを変更する必要が生じた際などに、 その変更が多くの部分に影響を与えるようなことが考えられます。 Iterator パターンでは、集約オブジェクトを生成するクラスが走査のための共通のインタフェースを与えるようにすることで、 変更すべき点を少なく抑える設計になっています。

## いつ使用すべきか

- コレクションオブジェクトに対して、内部構造を公開せずに要素へのアクセスを提供したい場合。
- コレクションオブジェクトが異なるデータ構造を持っていても、一貫した方法でアクセスする方法を提供したい場合。

## メリット

- コレクションの内部構造を隠蔽できる。
- 一貫したアクセス方法を提供できる。
- コレクションの実装が変更されても、アクセス方法は変わらない。

## デメリット

- 独自のイテレータを実装する場合、コードの複雑性が増すことがある。
- 単純な走査の場合、標準のループ構文の方がシンプルかもしれない。
