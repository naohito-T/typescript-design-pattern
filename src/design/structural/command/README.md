# Command パターン

## 概要

Commandパターンは、操作やアクションをオブジェクトとしてカプセル化することで、パラメーターを使ってメソッドを呼び出すことなく、操作を要求するクラス（Invoker）と操作を実行するクラス（Receiver）を分離します。  
これにより、操作のキューイングやログ取り、取り消し（Undo）のような機能をサポートすることが容易になります。  
また、あるオブジェクトに対して要求を送るということは**そのオブジェクトのメソッドを呼び出すことと同じ。**  
さまざまな要求を送ろうとすると、引数の数や種類を増やさなければなりませんが、 それには限界があります。そこで要求自体をオブジェクトにしてしまい、そのオブジェクトを引数に渡すようにします。それがCommandパターンです。

## このパターンでの単語

Invoker: 操作を要求するクラス
Receiver: 操作を実行するクラス

### いつ使用すべきか

- 履歴や取り消し機能を持つシステム、つまりアクションや変更の履歴を追跡したいとき。
- 高度な機能を持つシステムのコマンドを実装したいとき。
- コールバック関数や遅延処理など、実行を遅らせるか、特定の時点で複数のアクションを順序正しく実行したい場合。

### メリット

1. **柔軟性**: Commandパターンは、InvokerとReceiverの間の結合度を低くするため、システムが柔軟になります。
2. **再利用と組み合わせ**: 既存のコマンドを組み合わせて複雑な操作を構築することができる。
3. **遅延実行とキュー**: コマンドは遅らせて実行するか、特定の順序で実行するためのキューに保存できます。
4. **Undo/Redo**: コマンドの実行を取り消すか、再実行する機能を簡単にサポートすることができる。

### デメリット

1. **クラス数の増加**: すべての個別の操作やアクションのためにコマンドクラスを作成する必要があるため、システム内のクラスの数が増加する可能性があります。
